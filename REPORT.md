# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Доянова В.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Список в Прологе представляет из себя определенную последовательность элементов, он является односвязной, рекурсивной структурой. В отличие от императивных языков в Прологе список может быть либо пустым элементом, либо представлять из себя "голову" и "хвост" (первый узел списка и остальные узлы соответственно).
Таким образом, списки в Прологе похожи на традиционные массивы, линейные списки, но все-таки имеет определенные отличия (например, мы можем использовать списки в Прологе без определения размера и типа данных элементов перед работой).

## Задание 1.1: Предикат обработки списка

*`list_length(X,Y)` - определение длины списка 

Примеры использования:
```prolog
?- list_length([1,2,3,4, 'a','q'], L).
L = 6

?- list_length([1,1,1,1], 2).
no

?- list_length([1,1,1,1], 4).
yes

?- list_length([], L).
L = 0
```

Реализация:
```prolog
list_length([], 0).
list_length([_|T], L) :- list_length(T, L1), L is L1+1.
```
Если список пустой, то его длина равняется 0. Иначе рассматривается хвост списка, определяется его длина и к результату прибавляется 1.

*`is_member(X,Y)` - определение принадлежности элемента списку 

Примеры использования:
```prolog
?- is_member(1,[1,2,3,4,5]).
true

?- is_member(7,[1,2,3,4,5]).
no

?- is_member(X,[1,2,3,4,5]).
X = 1 ;
X = 2 ;
X = 3 ;
X = 4 ;
X = 5 ;
```

Реализация:
```prolog
is_member(Elem, [Elem|_]).
is_member(Elem, [_|Tail]) :- is_member(Elem, Tail).
```
Если список пначинается с нужного элемента, то этот элемент принадлежит списку. Иначе наличие элемента проверяется рекурсивно в хвосте списка.

*`list_append(X,Y,Z)` - объединение списка X и Y в список Z 

Примеры использования:
```prolog
?- list_append([1,2,3],[4,5,6], L).
L = [1,2,3,4,5,6]

?- list_append([345,234],[2,2,2], L).
L = [345,234,2,2,2]

?- list_append(X,Y, [a,b,c]).
X = []
Y = [a,b,c] ;
X = [a]
Y = [b,c] ;
X = [a,b]
Y = [c] ;
X = [a,b,c]
Y = [] ;
```

Реализация:
```prolog
list_append([], Elem, Elem).
list_append([Head|Tail], Elem,[Head|TailFinal]) :-list_append(Tail, Elem, TailFinal).
```
Если один из списков пуст, то результатом будет второй список. Иначе берется хвост первого списка и рекурсивно объединяется со вторым, результат записывается в TailFinal.

*`list_remove(X,Y,Z)` - удаление элемента X из списка Y, запись полученного списка в Z

Примеры использования:
```prolog
?- list_remove(1, [1,2,3], L).
L = [2,3] 

?- list_remove(2, [1,2,7,2,3,4,2], L).
L = [1,7,2,3,4,2] ;
L = [1,2,7,3,4,2] ;
L = [1,2,7,2,3,4] ;

?- list_remove(65, [1,2,7,2,3,4,2], L).
no
```

Реализация:
```prolog
list_remove(Elem, [Elem|Tail], Tail).
list_remove(Elem, [Head|Tail], [Head|TailFinal]) :- list_remove(Elem, Tail, TailFinal).
```
Если нужный элемент находится в голове списка, то результат - хвост списка. Иначе происходит поиск и удаление элемента в хвосте списка.

*`permute(X,Y)` - осуществление перестановок элементов списка

Примеры использования:
```prolog
?- permute([4,5,6],X).
X = [4,5,6] ;
X = [4,6,5] ;
X = [5,4,6] ;
X = [5,6,4] ;
X = [6,4,5] ;
X = [6,5,4] ;

?- permute([4,5,6],[6,5,4]).
true

?- permute([4,5,6],[6,5,7]).
no
```

Реализация:
```prolog
permute([],[]).
permute(Elem, [Head|Tail1]) :- list_remove(Head, Elem, Tail), permute(Tail,Tail1).
```
Если список пустой, то результатом будет пустой список. Иначе происходит удаление одного из элементов, оставшиеся переставляются, а удаленный элемент добавляется в новый список.

*`is_sublist(X,Y)` - проверка на принадлежность подсписка списку

Примеры использования:
```prolog
?- is_sublist([4,5,2,3,6,7],[2,3]).
true

?- is_sublist([4,5,2,3,6,7],[2,9]).
no

?- is_sublist([1,2,3],X).
X = [] ;
X = [1] ;
X = [] ;
X = [1,2] ;
X = [2] ;
X = [] ;
X = [1,2,3] ;
X = [2,3] ;
X = [3] ;
X = [] ;
```

Реализация:
```prolog
is_sublist(List, Slist) :- list_append(List1, _, List), list_append(_,Slist,List1).
```
Если из головы List1 возможно выделить Slist(подсписок), то подсписок принадлежит списку.

*`remove_elem1(X,Y,Z)` - Удаление всех элементов списка по значению (с помощью стандартных предикатов)

Примеры использования:
```prolog
?- remove_elem1(1,[1,1,1,1],L).
L = []

?- remove_elem1(6,[1,4,6,8],L).
L = [1,4]

?- remove_elem1(7,[1,4,6,8],L).
no
```

Реализация:
```prolog
remove_elem1(Elem, List1, List2) :- append(List2, [Elem|_], List1).
```
Append используется для слияния списков. List2 после слияния должен содержать в себе все элементы кроме Elem (который необходимо удалить из списка), так как мы объединяем его с частью списка, не содержащей Elem. Таким образом, новым списком без определенных элементов как раз будет List2.

*`remove_elem2(X,Y,Z)` - Удаление всех элементов списка по значению (без использования стандартных предикатов)

Примеры использования:
```prolog
?- remove_elem2(3,[1,4,3,9,5],L).
L = [1,4]

?- remove_elem2(11,[1,4,3,9,5],L).
no
```

Реализация:
```prolog
remove_elem2(Elem, [Elem|_],[]) :- !.
remove_elem2(Elem, [H|T],[H|T1]) :- remove_elem2(Elem, T, T1).
```
Рекурсивно обрабатываем список до тех пор, пока голова не будет равна нужному элементу. Когда это произошло, список становится пустым. Все элементы, которые шли до нужного, помещаются в новый список.

## Задание 1.2: Предикат обработки числового списка

*`sum1(X,Y)` - Вычисление суммы элементов (вариант 1)

Примеры использования:
```prolog
?- sum1([],S).
S = 0

?- sum1([-1,1,-1,1,5],S).
S = 5
```

Реализация:
```prolog
sum1([], 0).
sum1([H|T], S) :- sum1(T,S1), S is S1 + H.
```
Если список пустой, то сумма его элементов равна нулю. Иначе идем по списку и прибавляем каждый элемент в S.

*`sum2(X,Y)` - Вычисление суммы элементов (вариант 2)

Примеры использования:
```prolog
?- sum1([],S).
S = 0

?- sum1([-1,1,-1,1,5],S).
S = 5
```

Реализация:
```prolog
sum_2([], S, S).
sum_2([H|T],S1,S) :- S2 is H + S1, sum_2(T,S2,S).
sum2(List, S) :- sum_2(List, 0, S).
```
Мы вызываем sum2 для двух аргументов - списка и суммы. В переменной S2 находится промежуточная сумма, суммируем элементы хвоста, добавляя к ним голову. Когда список будет пустой, вся накопленная сумма перейдет в переменную S.

## Задание 2: Реляционное представление данных
Представление: four.pl
Вариант: 1

Преимущества реляционного представления данных:
1. Наглядное представление данных в виде таблиц;
2. Простота использования;
3. Операции над данными можно кратко описывать благодаря тому, что модель основана на строгом математическом аппарате.
Недостатки реляционного представления данных:
1. Реляционная база данных требует большого объёма памяти;
2. Невысокая производительность;
3. Не все данные удобно представлять в данном формате.

Преимущества представления four.pl:
1. Четкое разделение компонентов, позволяющее конкретно обращаться к нужной группе элементов;
2. Компактное, наглядное представление данных.

Недостатки представления four.pl:
1. Вложенность структур затрудняет поиск отдельных элементов.

Предикаты, осуществляющие запросы к данным:\n
*sum(X,Y) - нахождение суммы элементов.
*sr(X,Y) - нахождение среднего арифметического. 
*grades(X,Y) - получение всех оценок студента. Осуществляем проход по предметам, получая оценки студента.
*sr_student(X,Y) - получение среднего арифметического всех оценок студента. С помощью findall, куда передается оценка, получаем список оценок студента, от которого находим средний балл.
*sr_student_group(X,Y) - получение среднего балла каждого студента в группе каждого студента в определенной группе. Получаем список студентов группы, member осуществляет получение студента из определенной группы, для которого находится средний балл.
*sr_groups - печать таблицы групп и среднего балла каждой группы. С помощью findall получаем список всех средних баллов студентов конкретной группы, затем производим печать полученных значений.
*grade_2(X,Y) - поиск студента, не сдавшего экзамен. Получаем список студентов относительно предмета, затем с помощью member производим проверку оценки (она должна равняться 2).  
*print_grade_2 - печать студента, не сдавшего экзамен, и соответствующего предмета. С помощью findall получаем список студентов, несдавших экзамен, затем печатаем предмет и список студентов.
*grade_2_group(X,Y) - поиск студентов, не сдавших экзамен, в определенной группе. Осуществляем поиск студента определенной группы, оценка которого равна 2.
*sum_in_group(X,Y) - подсчет количества несдавших студентов. С помощью findall получаем список студентов, несдавших экзамен, затем получаем длину списка (она и будет количеством несдавшх студентов).
*print_grade_2_group - печать номера группы и количества несдавших студентов. Получаем количество несдавших студентов, печатаем номер группы и полученное количество.

Реализация:
% Получить таблицу групп и средний балл по каждой из групп
sum([], 0).
sum([H|T], S) :- sum(T,S1), S is S1 + H.
sr(L,Sr) :- length(L, Leng), sum(L,  Sum), Sr is Sum / Leng.
grades(Student, N) :- subject(_,X), member(grade(Student, N), X).
sr_student(Student, Sr) :- findall(X, grades(Student, X), List), sr(List, Sr).
sr_student_group(Group, Sr) :- group(Group, Students), member(Student, Students), sr_student(Student, Sr).
sr_groups :- group(Group, _), findall(X, sr_student_group(Group, X), List), sr(List, N), write('Group '), write(Group), write(', average grade: '), write(N), write('\n'), fail.

% Для каждого предмета получить список студентов, не сдавших экзамен (grade=2)
grade_2(Sub, Student) :- subject(Sub, Students), member(grade(Student, 2), Students).
print_grade_2 :- subject(Sub, _), findall(Student, grade_2(Sub, Student), List), write('Subject: '), write(Sub), write(' Did not pass: '), write(List), write('\n'), fail.

% Найти количество не сдавших студентов в каждой из групп
grade_2_group(Group, Student) :- subject(_,X), group(Group,Y), member(Student,Y),member(grade(Student,2),X).
sum_in_group(Group,Sum) :- findall(Student, grade_2_group(Group, Student), List), length(List, Sum).
print_grade_2_group :- group(Group, _), sum_in_group(Group, Sum), write(Group), write(' Number:  '), write(Sum), write('\n'), fail.

Пример использования:
?- sr_groups.
Group 102, average grade: 3.9444444444444446
Group 101, average grade: 3.9666666666666672
Group 104, average grade: 3.8611111111111112
Group 103, average grade: 4.1458333333333339

?- print_grade_2.
Subject: Логическое программирование Did not pass: [Петровский ,Сидоров,Джаво]
Subject: Математический анализ Did not pass: [Петров]
Subject: Функциональное программирование Did not pass: []
Subject: Информатика Did not pass: [Сиплюсплюсов,Криптовалютников]
Subject: Английский язык Did not pass: [Решетников,Азурин]
Subject: Психология Did not pass: [Безумников,Круглосчиталкин]

?- print_grade_2_group.
102 Number:  3
101 Number:  3
104 Number:  2
103 Number:  2

## Выводы
В данной лабораторной работе я ознакомилась с языком программирования Prolog. Данный язык программирования стал новым опытом для меня, так как он отличается от тех, на которых я раньше решала различные задачи. Основная сложность, возникшая в процессе работы, это непривычная среда программирования и неприывчный способ написания кода. Сложность нахождения ошибок при написании кода также являлось проблемой для меня. Однако написание самих команд стало интересным и необычным опытом, так как необходимо было "научить" программу действовать определенным образом. Также стоит отметить такую важную структуру как списки, потому что в ходе выполнения работы она задействовалась ни один раз. Так, в ходе выполнения второй части задания я использовала списки для вывода данных.
Таким образом, выполнение данной работы позволило мне ознакомиться с новым языком программирования, понять его основы и "правила", которые отличаются от привычных языков.
