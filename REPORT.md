# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Доянова В.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Список в Прологе представляет из себя определенную последовательность элементов, он является односвязной, рекурсивной структурой. В отличие от императивных языков в Прологе список может быть либо пустым элементом, либо представлять из себя "голову" и "хвост" (первый узел списка и остальные узлы соответственно).
Таким образом, списки в Прологе похожи на традиционные массивы, линейные списки, но все-таки имеет определенные отличия (например, мы можем использовать списки в Прологе без определения размера и типа данных элементов перед работой).

## Задание 1.1: Предикат обработки списка

*`list_length(X,Y)` - определение длины списка 

Примеры использования:
```prolog
?- list_length([1,2,3,4, 'a','q'], L).
L = 6

?- list_length([1,1,1,1], 2).
no

?- list_length([1,1,1,1], 4).
yes

?- list_length([], L).
L = 0
```

Реализация:
```prolog
list_length([], 0).
list_length([_|T], L) :- list_length(T, L1), L is L1+1.
```
Если список пустой, то его длина равняется 0. Иначе рассматривается хвост списка, определяется его длина и к результату прибавляется 1.

*`is_member(X,Y)` - определение принадлежности элемента списку 

Примеры использования:
```prolog
?- is_member(1,[1,2,3,4,5]).
true

?- is_member(7,[1,2,3,4,5]).
no

?- is_member(X,[1,2,3,4,5]).
X = 1 ;
X = 2 ;
X = 3 ;
X = 4 ;
X = 5 ;
```

Реализация:
```prolog
is_member(Elem, [Elem|_]).
is_member(Elem, [_|Tail]) :- is_member(Elem, Tail).
```
Если список пначинается с нужного элемента, то этот элемент принадлежит списку. Иначе наличие элемента проверяется рекурсивно в хвосте списка.

*`list_append(X,Y,Z)` - объединение списка X и Y в список Z 

Примеры использования:
```prolog
?- list_append([1,2,3],[4,5,6], L).
L = [1,2,3,4,5,6]

?- list_append([345,234],[2,2,2], L).
L = [345,234,2,2,2]

?- list_append(X,Y, [a,b,c]).
X = []
Y = [a,b,c] ;
X = [a]
Y = [b,c] ;
X = [a,b]
Y = [c] ;
X = [a,b,c]
Y = [] ;
```

Реализация:
```prolog
list_append([], Elem, Elem).
list_append([Head|Tail], Elem,[Head|TailFinal]) :-list_append(Tail, Elem, TailFinal).
```
Если один из списков пуст, то результатом будет второй список. Иначе берется хвост первого списка и рекурсивно объединяется со вторым, результат записывается в TailFinal.

*`list_remove(X,Y,Z)` - удаление элемента X из списка Y, запись полученного списка в Z

Примеры использования:
```prolog
?- list_remove(1, [1,2,3], L).
L = [2,3] 

?- list_remove(2, [1,2,7,2,3,4,2], L).
L = [1,7,2,3,4,2] ;
L = [1,2,7,3,4,2] ;
L = [1,2,7,2,3,4] ;

?- list_remove(65, [1,2,7,2,3,4,2], L).
no
```

Реализация:
```prolog
list_remove(Elem, [Elem|Tail], Tail).
list_remove(Elem, [Head|Tail], [Head|TailFinal]) :- list_remove(Elem, Tail, TailFinal).
```
Если нужный элемент находится в голове списка, то результат - хвост списка. Иначе происходит поиск и удаление элемента в хвосте списка.

*`permute(X,Y)` - осуществление перестановок элементов списка

Примеры использования:
```prolog
?- permute([4,5,6],X).
X = [4,5,6] ;
X = [4,6,5] ;
X = [5,4,6] ;
X = [5,6,4] ;
X = [6,4,5] ;
X = [6,5,4] ;

?- permute([4,5,6],[6,5,4]).
true

?- permute([4,5,6],[6,5,7]).
no
```

Реализация:
```prolog
permute([],[]).
permute(Elem, [Head|Tail1]) :- list_remove(Head, Elem, Tail), permute(Tail,Tail1).
```
Если список пустой, то результатом будет пустой список. Иначе происходит удаление одного из элементов, оставшиеся переставляются, а удаленный элемент добавляется в новый список.

*`is_sublist(X,Y)` - проверка на принадлежность подсписка списку

Примеры использования:
```prolog
?- is_sublist([4,5,2,3,6,7],[2,3]).
true

?- is_sublist([4,5,2,3,6,7],[2,9]).
no

?- is_sublist([1,2,3],X).
X = [] ;
X = [1] ;
X = [] ;
X = [1,2] ;
X = [2] ;
X = [] ;
X = [1,2,3] ;
X = [2,3] ;
X = [3] ;
X = [] ;
```

Реализация:
```prolog
is_sublist(List, Slist) :- list_append(List1, _, List), list_append(_,Slist,List1).
```
Если из головы List1 возможно выделить Slist(подсписок), то подсписок принадлежит списку.

*`remove_elem1(X,Y,Z)` - Удаление всех элементов списка по значению (с помощью стандартных предикатов)

Примеры использования:
```prolog
?- remove_elem1(1,[1,1,1,1],L).
L = []

?- remove_elem1(6,[1,4,6,8],L).
L = [1,4]

?- remove_elem1(7,[1,4,6,8],L).
no
```

Реализация:
```prolog
remove_elem1(Elem, List1, List2) :- append(List2, [Elem|_], List1).
```
Append используется для слияния списков. List2 после слияния должен содержать в себе все элементы кроме Elem (который необходимо удалить из списка), так как мы объединяем его с частью списка, не содержащей Elem. Таким образом, новым списком без определенных элементов как раз будет List2.

*`remove_elem2(X,Y,Z)` - Удаление всех элементов списка по значению (без использования стандартных предикатов)

Примеры использования:
```prolog
?- remove_elem2(3,[1,4,3,9,5],L).
L = [1,4]

?- remove_elem2(11,[1,4,3,9,5],L).
no
```

Реализация:
```prolog
remove_elem2(Elem, [Elem|_],[]) :- !.
remove_elem2(Elem, [H|T],[H|T1]) :- remove_elem2(Elem, T, T1).
```
Рекурсивно обрабатываем список до тех пор, пока голова не будет равна нужному элементу. Когда это произошло, список становится пустым. Все элементы, которые шли до нужного, помещаются в новый список.

## Задание 1.2: Предикат обработки числового списка

*`sum1(X,Y)` - Вычисление суммы элементов (вариант 1)

Примеры использования:
```prolog
?- sum1([],S).
S = 0

?- sum1([-1,1,-1,1,5],S).
S = 5
```

Реализация:
```prolog
sum1([], 0).
sum1([H|T], S) :- sum1(T,S1), S is S1 + H.
```
Если список пустой, то сумма его элементов равна нулю. Иначе идем по списку и прибавляем каждый элемент в S.

*`sum2(X,Y)` - Вычисление суммы элементов (вариант 2)

Примеры использования:
```prolog
?- sum1([],S).
S = 0

?- sum1([-1,1,-1,1,5],S).
S = 5
```

Реализация:
```prolog
sum_2([], S, S).
sum_2([H|T],S1,S) :- S2 is H + S1, sum_2(T,S2,S).
sum2(List, S) :- sum_2(List, 0, S).
```
Мы вызываем sum2 для двух аргументов - списка и суммы. В переменной S2 находится промежуточная сумма, суммируем элементы хвоста, добавляя к ним голову. Когда список будет пустой, вся накопленная сумма перейдет в переменную S.

## Задание 2: Реляционное представление данных

Опишите, в чем преимущества и недостатки реляционного представления в целом, и конкретного представления, которое вы использовали.

Опишите принцип реализации всех предикатов, осуществляющих запросы к данным.

## Выводы

Сформулируйте *содержательные* выводы по лабораторной работе. Чему она вас научила? Над чем заставила задуматься? Помните, что несодержательные выводы -
самая частая причина снижения оценки за лабораторную.




